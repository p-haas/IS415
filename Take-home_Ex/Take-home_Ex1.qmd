---
title: "Take-home Exercise - Application of Spatial Point Patterns Analysis"
subtitle: "Discover the geographical distribution of functional and non-function water points in Osun State, Nigeria"

author: "Pierre HAAS"

date: "February 03, 2023"
date-modified: "`r Sys.Date()`"

execute:
  eval: true
  echo: true
  warning: false
editor: visual

number-sections: true
---

# Introduction

# Getting Started

## Retrieving Data from the Web

Here, you will find a list with the data used, its type, format, and source it was extracted from.

| Type         | Data                                                               | Format | Source                                                                                                                                                                                                                                                                                                        |
|------------------|------------------|------------------|-------------------|
| *Geospatial* | State GIS boundary data of Nigeria - Administration Level 1, 2 & 3 | *.shp* | [OCHA](https://data.humdata.org/dataset/cod-ab-nga) data, extracted from the [Humanitarian Data Exchange](https://data.humdata.org/) portal ([data](https://data.humdata.org/dataset/81ac1d38-f603-4a98-804d-325c658599a3/resource/aa69f07b-ed8e-456a-9233-b20674730be6/download/nga_adm_osgof_20190417.zip)) |
| *Geospatial* | State GIS boundary data of Nigeria - Administration Level 2        | *.shp* | Data collected from [geoboundaries.org](https://www.geoboundaries.org/)                                                                                                                                                                                                                                       |
| *Aspatial*   | Water Point Data Exchange Plus                                     | *.csv* | [Data](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPDx-/eqje-vguj/data) extracted from WPdx Global Data Repositories                                                                                                                                                              |

Note that the *geoboundaries* and OCHA data serve the same purpose. I decided to included both data set before choosing the most convenient one, based on a practical analysis of the variables included in the data sets.

## Installing and Loading Packages

For the purpose of our analysis, we will be using the following libraries:

-   **sf**

-   **tmap**

-   **spatstat**

-   **raster**

-   **maptools**

-   **funModeling**

-   **tidyverse** and readr, dplyr, ggplot2 & tidyr dependencies

-   **pacman**

To installl and load the packages, we will be using the function *p_load()* of the **pacman** package. This will ensure that all packages are installed and loaded properly.

```{r}
#| code-fold: true
#| code-summary: Show code

pacman::p_load(sf, tmap, funModeling, maptools, spatstat, tidyverse, raster, sfdep)
```

# Handling Geospatial Data

## Importing Aspatial Data, *csv* format

::: panel-tabset
#### Import data

We use the *read_csv()* function from the **readr** package. This allows us to import the water point file into our R notebook. We will store the data set under the variable *wp_nga*.

```{r}
#| warning: false
#| code-fold: true
#| code-summary: Show code

wp_nga = read_csv("data/aspatial/Water_Point_Data_Exchange_-_Plus__WPdx__.csv", show_col_types = FALSE)
```

#### Glimpse

Before diving into Data Wrangling, the first step is to get an understanding of the data and its attributes. By using the function *glimpse()* of the **dplyr** package, we will be able to view the attributes of this data set and data type of each field.

```{r}
glimpse(wp_nga)
```

The output reveals that we have a tible data frame -- *wp_nga* -- composed of 406,566 data points and 70 columns. It is now time to take a few seconds to browse through the data to get a proper look at the different attributes in the data set.

Since our goal is to observe data only from the Osun state in Nigeria, we should take a look at the attributes that will allow us to filter the data set. It seems like the columns: *clean_country_name* & *clean_adm1* contain the information about the country and state of the water points.

#### Region filter

Using the *filter()* function, we will be to select on data points from the Osun state in Nigeria.

```{r}
wp_nga = wp_nga %>% 
  filter(`#clean_country_name` == "Nigeria" & `#clean_adm1` == "Osun")
```

To check if there are no mistake, we can use the function *unique()* to help us view all the unique strings in the columns *clean_country_name* & *clean_adm1*

```{r}
unique(wp_nga$`#clean_adm1`); unique(wp_nga$`#clean_country_name`)
```

We obtained the desired output, we are only left with data points located in Osun state, Nigeria
:::

### Converting water point data into *sf* point features

Using the *st_as_sfc()* function of the **sf** package, we convert the [wkt](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) field -- *\`New Georeferenced Column\`* --into a sfc field.

```{r}
wp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)
wp_nga
```

Now, we can convert the tibble data frame into a **sf** object using the *st_sf()* function. We shall also specify the georeferencing system (crs code). Here, it seems like the data is referenced in WGS84.

```{r}
wp_sf <- wp_nga %>%
  st_sf(crs=4326)
wp_sf
```

### Transforming into Nigeria projected coordinate system

Using the function *st_transform()*, we transform the **sf** coordinates of our data points into the Nigerian projected coordinate system.

Note that there are three Projected Coordinate Systems of Nigeria, they are: EPSG: 26391, 26392, and 26303. For the purpose of our analysis, we will choose EPSG: 26391.

```{r}
wp_sf <- wp_sf %>%
  st_transform(crs = 26391)
```

## Importing Geospatial Data, *shp* format

### The NGA data set

::: panel-tabset
#### Import data

We use the function st_read() from sf package to import our geospatial data. Here, we import the NGA data set, which is stored in our data folder as a shp file. Since our analysis is focused on the Osun State (Nigeria), we will use the filter() function to select the data corresponding to the Administration Level 1 of Osun State.

```{r}
nga = st_read(dsn = "data/geospatial",
                   layer = "nga_admbnda_adm2") %>%
  filter(ADM1_EN == "Osun")
```

#### Check CRS

Before proceeding to the next steps, I would like to retrieve the CRS code from the sf object to perform a quick check that the CRS and code match. To do so, we use the st_crs() function which helps us do that.

```{r}
st_crs(nga)
```

The CRS and id match, therefore we can move on to the next step and transform the data into the Nigerian projected coordinate system.

#### st_transform()

As explained before, using st_transform(), we convert the sf coordinates into the Nigerian projected coordinate system.

```{r}
nga <- nga %>%
  st_transform(crs = 26391)
nga
```

The projected CRS now corresponds to the Nigerian one, we will be able to perform data wrangling from now on.
:::

### The geoBoundaries data set

In this section, we will follow the same steps as the NGA data set but for the geoBoundaries data this time, however, since we will choose the NGA data over the latter, we can refrain from performing the next steps. Yet, I include the code if one chooses to work with the geoBoundaries data set.

::: panel-tabset
#### Import data

```{r}
#| eval: false
#| code-fold: true
#| code-summary: Show code

geoNGA = st_read(dsn = "data/geospatial",
                 layer = "geoBoundaries-NGA-ADM2")
```

#### st_crs()

```{r}
#| eval: false
#| code-fold: true
#| code-summary: Show code

st_crs(geoNGA)
```

#### st_tansform()

```{r}
#| eval: false
#| code-fold: true
#| code-summary: Show code

geoNGA <- geoNGA %>%
  st_transform(crs = 26391)
geoNGA
```
:::

# Data Cleaning

## Geospatial Data Cleaning

### Excluding redundant fields

To simplify our work, we shall reduce our data set and use only necessary attributes. Using the select() function, we will choose fields 3, 4, 8, and 9. By doing so, we exclude redundant fields.

```{r}
nga <- nga %>%
  dplyr::select(c(3:4, 8:9))
```

Note that the Geometry field remains in our sf data frame.

### Checking for duplicated name

Checking for duplicates is an essential part of data cleaning. Here, we shall check if any ... have the same name within the Osun State.

```{r}
nga$ADM2_EN[duplicated(nga$ADM2_EN)==TRUE]
```

There are no duplicates in the data set. We shall then move on to the data wrangling of the water points.

## Data Wrangling for Water Point Data

Given the nature of our work which focuses on analyzing the distribution of functional and non-functional water points throughout the Osun State in Nigeria, we should explore the attribute that stores such information.

Looking back at the previous work done, it seems that the field `#status_clean` indicates the nature of the water point. By using the freq() function from the funModeling package, we display the information about the water points on a bar plot.

```{r}
#| warning: false

funModeling::freq(data = wp_sf,
     input = '#status_clean')
```

Looking at the above bar plot, we learn that:

-   15% of observations are not classified, we should treat that issue next;

-   the functional water points are classified into 3 categories, namely "Functional", "Functional but needs repair", and "Functional but in use";

-   the non-functional water points are classified into 4 categories, namely "Non-Functional", "Non-Functional due to dry season", "Abandoned", and "Abandoned/Decommissioned";

Before extracting the water point data, we will simplify our work by creating an alternate data frame using the rename(), select(), and mutate() functions.

-   We use rename() to rename the '#status_clean' field to status_clean, it will make data handling easier;

-   We use select() of the dplyr package to include the status_clean attribute in the output sf data frame;

-   We use replace_na() to change all NA values from the status_clean column into unknown.

```{r}
wp_sf_nga <- wp_sf %>% 
  rename(status_clean = '#status_clean') %>%
  dplyr::select(status_clean) %>%
  mutate(status_clean = replace_na(
    status_clean, "unknown"))
head(wp_sf_nga)
```

### Extracting water point data

In order to perform tests on the different water point categories, we should extract the water point data according to their status. We will use the function filter() to do so, and shall include all relevant categories to functional and non-functional water points as mentioned earlier.

```{r}
wp_sf_functional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but not in use",
             "Functional but needs repair"))
```

```{r}
wp_sf_nonfunctional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Abandoned",
             "Non-Functional due to dry season",
             "Non-Functional"))
```

```{r}
#freq(data = wp_sf_functional,
 #    input = 'status_clean')
```

```{r}
#freq(data = wp_sf_nonfunctional,
 #    input = 'status_clean')
```

### Performing Point-in-Polygon Count

```{r}
nga_wp <- nga %>% 
  mutate(`total_wp` = lengths(
    st_intersects(nga, wp_sf_nga))) %>%
  mutate(`wp_functional` = lengths(
    st_intersects(nga, wp_sf_functional))) %>%
  mutate(`wp_nonfunctional` = lengths(
    st_intersects(nga, wp_sf_nonfunctional)))
```

```{r}
ggplot(data = nga_wp,
       aes(x = wp_nonfunctional)) + 
  geom_histogram(bins=20,
                 color="black",
                 fill="light blue") +
  geom_vline(aes(xintercept=mean(
    wp_nonfunctional, na.rm=T)),
             color="red", 
             linetype="dashed", 
             size=0.8) +
  ggtitle("Distribution of total water points by LGA") +
  xlab("No. of water points") +
  ylab("No. of\nLGAs") +
  theme(axis.title.y=element_text(angle = 0))
```

# Geospatial Data Wrangling

In order to perform first-order spatial point pattern analysis and plot kernel density estimation maps, a few necessary steps remain. Indeed, **spatstat** package requires us to use analytical data in *ppp* object form. We call that geospatial data wrangling. In the following parts, we will convert our **sf** data frames into *ppp* and *owin* objects.

Note that we will be working with the three following data frames:

-   ***wp_sf_functional**,* being the **sf** data frame that stores the geometry of functional water points;

-   ***wp_sf_nonfunctional***, being the **sf** data frame that stores the geometry of non-functional water points;

-   ***nga***, being the **sf** data frame that stores the geometry of level 2 administrative boundaries in Nigeria;

## Converting *sf* data frames to *sp's* Spatial\* class

The first step to converting an sf data frame to a ppp class object is to use the as_Spatial() function of the sf package. It converts the geospatial data from sf data frame to sp's Spatial\* class.

Below, we perform this transformation on the three data frames.

::: panel-tabset
### Functional Water Points

```{r}
wp_functional = as_Spatial(wp_sf_functional)
wp_functional
```

Note that ***wp_functional*** is a Spatial Points data frame.

### Non-Functional Water Points

```{r}
wp_nonfunctional = as_Spatial(wp_sf_nonfunctional)
wp_nonfunctional
```

Note that ***wp_nonfunctional*** is a Spatial Points data frame.

### Level-2 Administrative boundaries

```{r}
nga_spat = as_Spatial(nga)
nga_spat
```

Note that ***nga_spat*** is a Spatial Polygons data frame.
:::

## Converting the Spatial\* class into generic *sp* format

:::panel-tabset

### Functional Water Points

```{r}
wp_functional_sp <- as(wp_functional, "SpatialPoints")
wp_functional_sp
```

### Non-Functional Water Points

```{r}
wp_nonfunctional_sp <- as(wp_nonfunctional, "SpatialPoints")
wp_nonfunctional_sp
```

### Level-2 Administrative boundaries

```{r}
nga_sp <- as(nga_spat, "SpatialPolygons")
nga_sp
```

## Converting the generic *sp* format into *spatstat's* ppp format

```{r}
wp_functional_ppp <- as(wp_functional_sp, "ppp")
wp_nonfunctional_ppp <- as(wp_nonfunctional_sp, "ppp")
```

```{r}
wp_functional_ppp
```

```{r}
plot(wp_functional_ppp)
```

## Creating *owin* object

```{r}
nga_owin <- as(nga_sp, "owin")
plot(nga_owin)
```

## Combining point events object and *owin* object

```{r}
wp_functional_ppp = wp_functional_ppp[nga_owin]
wp_nonfunctional_ppp = wp_nonfunctional_ppp[nga_owin]
```

```{r}
plot(wp_functional_ppp)
```

# Exploratory Spatial Data Analysis

This section has for objective:

-   Deriving kernel density maps of functional and non-functional water points

-   Display kernel density maps of the [Osun State, Nigeria]{.underline} on ***openstreetmap*** using appropriate ***tmap*** functions

-   Describe the spatial patterns revealed by the kernel density maps & highlight the advantage of kernel density map over point map

## Kernel Density Estimation

Our first step to KDE is to derive two density maps for functional and non-functional water points to check for any potential data problem. Here, we suspect that the scale of density values will be expressed in meters. The default measurement unit of Nigeria's projected coordinate system -- [EPSG:26391](https://epsg.io/26391) -- is expressed in meters. We shall verify that and correct it to kilometers to get a more desirable map output (scale).

For starters, we should use the *density()* function to compute kernel density estimates for both types of water points. We will use two methods for smoothing the bandwidth for the kernel estimation point process intensity.

::: panel-tabset
#### Adaptive Bandwidth

The first method uses adaptive estimate of the intensity function of a point pattern. We plot side-by-side the KDE maps for functional and non-functional WP.

```{r}
#| warning: false
#| code-fold: true
#| code-summary: Show code

kde_wpfunc.m <- adaptive.density(wp_functional_ppp,
                                  method = "kernel")

kde_wpnonfunc.m <- adaptive.density(wp_nonfunctional_ppp,
                                     method = "kernel")

par(mfrow=c(1,2))
plot(kde_wpfunc.m,
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wpnonfunc.m,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```

We observe potential clustering as some areas of the maps seem to have higher concentration of observations.

We also observe that the scale is set in meters, thus we will take action and re-scale our data points to kilometers.

#### Automatic Bandwidth

Please find an alternative method for computing the bandwidth of our kernel density estimations.

```{r}
#| warning: false
#| code-fold: true
#| code-summary: Show code

kde_wpfunc.mppl <- density(wp_functional_ppp, 
                               sigma=bw.ppl, 
                               edge=TRUE)

kde_wpnonfunc.mppl <- density(wp_nonfunctional_ppp,
                             sigma=bw.ppl,
                             edge=TRUE)

par(mfrow=c(1,2))
plot(kde_wpfunc.mppl, 
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wpnonfunc.mppl,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```
:::

The density values of the output range from 0 to 0.000006 and it makes for an output difficult to comprehend and interpret. Thus, we will re-scale our density values to get an output in "number of points per square kilometer".

### Re-scalling KDE values

To change the scale of the density values, we use the *rescale()* function from the ***spatstat.geom*** package. Here, we multiply values of our two objects of class *ppp* by 1000. We thus express them in kilometers and define the unit name to be "km".

```{r}
wp_functional_ppp.km <- rescale(wp_functional_ppp, 1000, "km")

wp_nonfunctional_ppp.km <- rescale(wp_nonfunctional_ppp, 1000, "km")
```

We can now run the previously used *density()* function using the re-scaled data and plot the output KDE map.

::: panel-tabset
#### Adaptive Bandwidth

```{r}
#| warning: false
#| code-fold: true
#| code-summary: Show code

kde_wpfunc.km <- adaptive.density(wp_functional_ppp.km,
                                  method = "kernel")

kde_wpnonfunc.km <- adaptive.density(wp_nonfunctional_ppp.km,
                                     method = "kernel")

par(mfrow=c(1,2))
plot(kde_wpfunc.km,
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wpnonfunc.km,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```

#### Automatic Bandwidth

```{r}
#| warning: false
#| code-fold: true
#| code-summary: Show code

kde_wpfunc.ppl <- density(wp_functional_ppp.km,
                          sigma = bw.ppl,
                          edge = TRUE)

kde_wpnonfunc.ppl <- density(wp_nonfunctional_ppp.km,
                             sigma = bw.ppl,
                             edge = TRUE)

par(mfrow=c(1,2))
plot(kde_wpfunc.ppl,
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wpnonfunc.ppl,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```
:::

We start observing signs of potential clustering but, for now, we shall focus on transforming our *im* objects into *rasters* to plot our KDE maps using the ***tmap*** package. We will talk more about CSR and clustering later.

### Convert KDE output into grid object

::: panel-tabset
#### Adaptive Bandwidth

```{r}
#| warnin: false
#| code-fold: true
#| code-summary: Show code
#| fig-subcap:
#|   - "Functional Water Points"
#|   - "Non-Functional Water Points"
#| layout-ncol: 2

gridded_wpfunc <- as.SpatialGridDataFrame.im(kde_wpfunc.km)
gridded_wpnonfunc <- as.SpatialGridDataFrame.im(kde_wpnonfunc.km)

spplot(gridded_wpfunc)
spplot(gridded_wpnonfunc)
```

#### Automatic Bandwidth

```{r}
#| warnin: false
#| code-fold: true
#| code-summary: Show code
#| fig-subcap:
#|   - "Functional Water Points"
#|   - "Non-Functional Water Points"
#| layout-ncol: 2

gridded_wpfunc.ppl <- as.SpatialGridDataFrame.im(kde_wpfunc.ppl)
gridded_wpnonfunc.ppl <- as.SpatialGridDataFrame.im(kde_wpnonfunc.ppl)

spplot(gridded_wpfunc.ppl)
spplot(gridded_wpnonfunc.ppl)
```
:::

### Converting grid object into raster

::: panel-tabset
#### Functional

```{r}
kde_wpfunc_raster <- raster(gridded_wpfunc)
kde_wpfunc_raster
```

#### Non-functional

```{r}
kde_wpnonfunc_raster <- raster(gridded_wpnonfunc)
kde_wpnonfunc_raster
```
:::

### Assigning projection systems

::: panel-tabset
#### Functional WP

```{r}
#| code-fold: true
#| code-summary: Show code

projection(kde_wpfunc_raster) <- CRS("+init=EPSG:26391 +datum:WGS84 +units=km")
kde_wpfunc_raster
```

#### Non-functional WP

```{r}
projection(kde_wpnonfunc_raster) <- CRS("+init=EPSG:26391 +datum:WGS84 +units=km")
kde_wpnonfunc_raster
```
:::

## Visualizing KDE with tmap

::: panel-tabset
#### Functional WP map

```{r}
tmap_mode('view')
tm_basemap("OpenStreetMap") +
tm_shape(kde_wpfunc_raster) +
  tm_raster("v")
```

#### Non-functional WP map

```{r}
tmap_mode('view')
tm_basemap("OpenStreetMap") +
tm_shape(kde_wpnonfunc_raster) +
  tm_raster("v")
```
:::

## Nearest Neighbor Index

Before moving on to the Second-order Spatial Points Analysis, I would like to perform the Clark-Evans test to measure aggregation of functional and non-functional water points. The goal is to test the randomness of the data points and assess whether they are randomly distributed, clustered or dispersed.

We will perform a series of 2 tests, first on functional water points and, second, on non-functional water points. We will be using the *clarkevans.test()* function of the **spatstat** package.

The hypotheses are the following:

***Test 1***

**H~0~ :** Functional Water Points are randomly distributed

**H~1~ :** Functional Water Points are not randomly distributed, they are clustered

***Test 2***

**H~0~ :** Non-functional Water Points are randomly distributed

**H~1~ :** Non-functional Water Points are not randomly distributed, they are clustered

As you may have read above, we determine the alternative hypothesis to be that water points are clustered. This decision is based on an intuition that derives from the previously seen visual representations of functional and non-functional water points. Indeed, we observed in our KDE plots some concentration of data points across the Osun State. Thus, we would like to test for clustering directly to prove this intuition.

Please note that when conducting our tests, we will use a 5% significance level.

::: panel-tabset
#### Test 1 functional WP

First test on functional water points.

```{r}
clarkevans.test(wp_functional_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("clustered"),
                nsim=99)
```

#### Test 2 non-functional WP

Second test on non-functional water points

```{r}
clarkevans.test(wp_nonfunctional_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("clustered"),
                nsim=99)
```
:::

### Conclusion of the test

Conclusion?

# 7 - Second-order Spatial Point Patterns Analysis

## 7.1 - Formulate the null hypothesis and alternative hypothesis and select the confidence level

## 7.2 - Perform the test by using appropriate Second order spatial point patterns analysis technique

```{r}
# G_tm = Gest(wp_functional_ppp, correction = "best")
# plot(G_tm)
```

```{r}
#L_wpfunc = Lest(wp_functional_ppp, correction = "Ripley")
#plot(L_wpfunc, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```

```{r}
1:30
```

```{r}
#for (i in 1:30){
 # nga1 = nga[i,]
  #print(nga1)
  #nga_spat = as_Spatial(nga1)
  #nga_sp = as(nga_spat, "SpatialPolygons")
  #nga_owin = as(nga_sp, "owin")
  #wp_functional_R = wp_functional_ppp[nga_owin]
  #L_wp1.csr <- envelope(wp_functional_R, Lest, nsim = 39, rank = 1, glocal=TRUE)
  #plot(L_wp1.csr, . - r ~ r, xlab="d", ylab="L(d)-r", main = #"L-test for Functional WP in Borepe")
#}
```

```{r}
#nga1 = nga[1,]
#nga1
```

```{r}
#nga_spat
```

```{r}
# L_wp1.csr <- envelope(wp1_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
# plot(L_wp1.csr, . - r ~ r, xlab="d", ylab="L(d)-r", main = "L-test for Functional WP in Borepe")
```

## 7.3 - With reference to the analysis results, draw statistical conclusions

# 8 - Spatial Correlation Analysis

In this section, you are required to confirm statistically if the spatial distribution of functional and non-functional water points are independent from each other.

## 8.1 - Formulate the null hypothesis and alternative hypothesis and select the confidence level

## 8.2 - Perform the test by using appropriate Second order spatial point patterns analysis technique

```{r}
water_points = wp_sf_nga %>%
  mutate(status_clean = recode(status_clean, "Functional but not in use" = 'Functional', "Functional but needs repair" = 'Functional', "Abandoned/Decommissioned" = 'Non-Functional', "Abandoned" = 'Non-Functional', "Non-Functional due to dry season" = 'Non-Functional')) %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but not in use",
             "Functional but needs repair",
             "Abandoned/Decommissioned",
             "Abandoned",
             "Non-Functional due to dry season",
             "Non-Functional"))
```

```{r}
nb = include_self(st_knn(st_geometry(water_points), 6))

wt = st_kernel_weights(nb, water_points, "gaussian", adaptive = TRUE)
```

```{r}
functional = water_points %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but not in use",
             "Functional but needs repair"))

A = functional$status_clean
```

```{r}
nonfunctional = water_points %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Abandoned",
             "Non-Functional due to dry season",
             "Non-Functional"))

B = nonfunctional$status_clean
```

```{r}
LCLQ = local_colocation(A, B, nb, wt, 49)
```

```{r}
LCLQ_stores = cbind(water_points, LCLQ)
```

```{r}
tmap_mode("view")
tm_shape(nga)+
  tm_polygons()+
tm_shape(LCLQ_stores)+
  tm_dots(col = c("Non.Functional"),
          size = 0.01,
          border.col = "black",
          border.lwd = 0.5)#+
  #tm_view(set.zoom.limits = c(12, 16))
```

## 8.3 - With reference to the analysis results, draw statistical conclusions
